# Эмулятор RISC-V

## Описание работы

Необходимо смоделировать работу системы “процессор-кэш-память” при выполнении кода на RISC-V с политиками вытеснения LRU и bit-pLRU.

Аргументы программе передаются через командную строку и могут располагаться в любом порядке относительно друг друга.

| Аргументы                              | Комментарии  																							      |
|:--------------------------------------:|:--------------------------------------------------------------------------------------------------------------:|
| -i <имя_файла>                         |Состояние регистров и оперативной памяти регистров перед началом исполнения.                                    |
| -o <имя_файла> <адрес_начала> <размер> | [Опционально] Состояние регистров и оперативной памяти (как её видит исполняемый код) по окончании исполнения. |

Вывод результата моделирования (число попаданий к общему числу обращений в процентах) производится в поток вывода в формате printf. Кроме общего процента попадания необходимо вычислить процент попадания отдельно для инструкций и для данных.

`"replacement\thit rate\thit rate (inst)\thit rate (data)\n"`

`"        LRU\t%3.5f%%\t%3.5f%%\t%3.5f%%\n"`

`"      bpLRU\t%3.5f%%\t%3.5f%%\t%3.5f%%\n"`

В случае, когда не было обращений к памяти, следует выводить nan%

Для вывода результата настоятельно рекомендуется использовать printf в C и printf/format в C++. Расхождение даже в один пробельный символ или потерянный знак % приведёт к тому, что ответ не будет зачтён.
### Входной файл
Двоичный файл в формате:

Первые 32*4 байта
состояние регистров: pc, x1, …, x31
Фрагменты оперативной памяти в формате
4 байта – адрес начала
4 байта – размер данного фрагмента N
N байт – фрагмент оперативной памяти

Состояние памяти вне поданных фрагментов неопределено.

Необходимо поддерживать команды RV32I и RV32M.

### Выходной файл
Аналогичен входному, но содержит только 1 фрагмент памяти.

### Исполнение команд
Команды исполняются последовательно и читаются из памяти только перед непосредственным исполнением одной операцией чтения.

Концом исполнения кода программы считается переход на адрес, содержащийся в регистре ra на старте программы.

Гарантируется, что в памяти команды и данные не пересекаются (например, команда записи в память не изменит исходные команды).

Многобайтовое обращение считается за одну операцию. Гарантируется, что все обращения к памяти выровненные (адрес начала кратен размеру порции данных).

Команды ecall и ebreak приводят к завершению исполнения. 

### Кэш-память
Моделируемый кэш общий для данных и команд. По реализации должно быть однозначно понятно, что кэш реализован нужной конфигурации!
Начальное состояние – кэш пуст (все кэш-линии в состоянии invalid).
Переменные/константы (как они должны называться в коде):
* MEMORY_SIZE – размер памяти (в байтах)
* CACHE_SIZE – размер кэша без учёта служебной информации (в байтах)
* CACHE_LINE_SIZE – размер кэш-линии (в байтах)
* CACHE_LINE_COUNT – кол-во кэш-линий
* CACHE_WAY – ассоциативность
* CACHE_SET_COUNT –  кол-во блоков кэш-линий
* ADDRESS_LEN – длина адреса (в битах)
* CACHE_TAG_LEN –  длина тэга адреса (в битах)
* CACHE_INDEX_LEN – длина индекса блока кэш-линий  (в битах)
* CACHE_OFFSET_LEN – длина смещения внутри кэш-линии (в битах)

Интерпретация адреса кэшем (слева старшие биты, справа – младшие):

| tag      | index | offset |
|:--------:|:-----:|:------:|
|CACHE_TAG_LEN | CACHE_INDEX_LEN |CACHE_OFFSET_LEN |

### Параметры системы
Ниже указаны различные варианты (номер варианта в таблице курса). Пустые ячейки – параметр необходимо вычислить самостоятельно. 
| Параметры               | Данные                                 |
|:-----------------------:|:--------------------------------------:|
|Конфигурация кэша        | look-through write-back write-allocate |
|Политика вытеснения кэша | LRU и bit-pLRU                         |
|MEMORY_SIZE              | 262144                                 |
|ADDRESS_LEN              | 18                                     |
|CACHE_TAG_LEN            | 8                                      |
|CACHE_INDEX_LEN          | 5                                      |
|CACHE_OFFSET_LEN         | 5                                      |
|CACHE_SIZE               | 4096                                   |
|CACHE_LINE_SIZE          | 32                                     |
|CACHE_LINE_COUNT         | 128                                    |
|CACHE_SET_COUNT          | 32                                     |
|CACHE_WAY                | 4                                      |

### task.bin
Помимо программы в репозиторий необходимо загрузить task.bin, который будет содержать такое состояние памяти и регистров, при котором в результате исполнения:
1. произойдёт хотя бы одно вытеснение из кэша;
2. для хотя бы одной из политик вытеснения будут достигнуты проценты (проценты представлены в таблице курса на листе ЛР3).

Будет полезным приложить в репозиторий task.asm, в котором вы опишите на ассемблере RISC-V тот код, который лежит в вашем task.bin. Так будет проще дать вам информативную обратную связь при возникновении проблем.

В автотестах будет производиться запуск с вашим task.bin файлом.
	
